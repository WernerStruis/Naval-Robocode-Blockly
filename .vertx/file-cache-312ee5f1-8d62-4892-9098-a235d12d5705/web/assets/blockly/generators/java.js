/**
 * @license
 * Visual Blocks Language
 *
 * Copyright 2012 Google Inc.
 * https://developers.google.com/blockly/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Helper functions for generating Java for blocks.
 * @author colin.heppener@nl.thalesgroup.com (Colin Heppener) /for the Naval Robocode specific alterations/
 * @author toebes@extremenetworks.com (John Toebes)
 * Loosely based on Python version by fraser@google.com (Neil Fraser)
 */
'use strict';

goog.provide('Blockly.Java');
goog.require('Blockly.Generator');
goog.require('Blockly.Variables');
/**
 * Java code generator.
 * @type !Blockly.Generator
 */
Blockly.Java = new Blockly.Generator('Java');

Blockly.Java.ORDER_NONE = 99;             // (...)


//Ship data
Blockly.Java.API;
Blockly.Java.ShipName = "MyShip";
Blockly.Java.Package = 'BlocklyShips';
Blockly.Java.BaseClass = "";
Blockly.Java.Imports = [];
Blockly.Java.Slots_ = [];
Blockly.Java.slot1Methods = {};
Blockly.Java.slot2Methods = {};
Blockly.Java.slot3Methods = {};
Blockly.Java.slot4Methods = {};

/**
 * List of variables
 * All use the Object class
 */
Blockly.Java.Variables = [];

//list of variables visited during generation
//if a variable is not visited after this, it gets deleted and excluded from the code
Blockly.Java.visitedVariables = [];




Blockly.Java.fileHeader = "\n/*<GENERATED BY BLOCKLY JAVA GENERATOR>*/\n";

Blockly.Java.forceUpdate = function (root) {
    var blocks;
    if (root.getDescendants) {
        // Root is Block.
        blocks = root.getDescendants();
    } else if (root.getAllBlocks) {
        // Root is Workspace.
        blocks = root.getAllBlocks();
    } else {
        throw 'Not Block or Workspace: ' + root;
    }
    // Iterate through every block and call the onchange function.
    for (var x = 0; x < blocks.length; x++) {
        if (blocks[x].onchange) {
            blocks[x].onchange(x);
        }
    }
};


/*
 * Save away the base class implementation so we can call it but override it
 * so that we get to modify the generated code.
 */
Blockly.Java.workspaceToCode_ = Blockly.Java.workspaceToCode;
/**
 * Generate code for all blocks in the workspace to the specified language.
 * @param {Blockly.Workspace} workspace Workspace to generate code from.
 * @param {string} parms Any extra parameters to pass to the lower level block
 * @return {string} Generated code.
 */

Blockly.Java.workspaceToCode = function (workspace, parms) {

    // Generate the code first to get all of the required imports calculated.
    this.forceUpdate(workspace);

    //this.setBaseClass('CarrierShip');
    //this.setShipName('TestShip');
    //this.addSlot('DoubleBarrelCannon');
    //this.addSlot('SingleBarrelCannon');
    //this.setAppName(workspace.options.appTitle);


    var code = this.workspaceToCode_(workspace, parms);
    var finalcode = 'package ' + this.getPackage() + ";\n";
    finalcode += getImportsString(this.getImports());

    finalcode += 'public class ' + this.getShipName() + ' extends ' + this.getBaseConfig() + '{\n\n';
    finalcode += Blockly.Java.prefixLines(code, Blockly.Java.INDENT);
    finalcode += Blockly.Java.prefixLines(this.getSlotSetters(), Blockly.Java.INDENT);
    finalcode += '}';


    return finalcode;
};

Blockly.Java.getSlotSetters = function getSlotSetters() {
    var setSlotString = '\n\n';
    var slots = this.getSlots();
    if (slots) {
        for (var i = 0; i < slots.length; i++) {
            setSlotString += '@Override\n';
            setSlotString += 'public ' + slots[i] + ' setSlot' + (i + 1) + '(){\n';
            setSlotString += Blockly.Java.prefixLines('return new ' + slots[i] + '();\n', Blockly.Java.INDENT);
            setSlotString += '}\n\n';
        }
    }
    return setSlotString + '\n\n'
};

Blockly.Java.getBaseConfig = function getBaseConfig() {
    var baseConfig = this.getBaseClass() + '<';
    var slots = this.getSlots();
    if (slots) {
        for (var i = 0; i < slots.length - 1; i++) {
            baseConfig += slots[i] + ', ';
        }
        baseConfig += slots[slots.length - 1];
    }
    return baseConfig += '>';
};


function getImportsString(imports) {
    var importsString = '\n';
    if (imports) {
        for (var i = 0; i < imports.length; i++) {
            importsString += 'import ' + imports[i] + ';\n';
        }
    }
    return importsString + '\n';
}

/**
 * Initialise the database of variable names.
 * @param {!Blockly.Workspace} workspace Workspace to generate code from.
 */
Blockly.Java.init = function (workspace, imports) {

    //// Create a dictionary of definitions to be printed before the code.
    //this.definitions_ = Object.create(null);
    // Create a dictionary mapping desired function names in definitions_
    // to actual function names (to avoid collisions with user functions).
    this.functionNames_ = Object.create(null);


    ////// Create a dictionary of all the libraries which would be needed
    ////this.imports_ = Object.create(null);
    ////// Dictionary of any extra classes to output
    ////this.classes_ = Object.create(null);
    // Dictionary of all the globals
    this.globals_ = Object.create(null);
    ////// Start with the defaults that all the code depends on
    //////for(var i = 0; i < this.needImports_.length; i++) {
    //////    this.addImport(this.needImports_[i]);
    //////}
    //if (!this.variableDB_) {
    //    this.variableDB_ =
    //        new Blockly.Names();
    //} else {
    //    this.variableDB_.reset();
    //}
    //
    //var defvars = [];
    ////Blockly.VariableTypeEquivalence['Colour'] = ['String'];
    //var variables = Blockly.Variables.allVariables(workspace);
    //this.blocklyTypes_ = Blockly.Variables.allVariablesTypes(workspace);
    //// Make sure all the type variables are pushed.  This is because we
    //// Don't return the special function parameters in the allVariables list
    //for (var name in this.blocklyTypes_) {
    //    variables.push(name);
    //}
    //for (var x = 0; x < variables.length; x++) {
    //    var key = variables[x];
    //    this.variableTypes_[key] = this.mapType(this.blocklyTypes_[key]);
    //}
};
//Blockly.Java.typeMapping = {
//    'Object' : 'Object',
//    'Array':   'LinkedList',
//    'Map':     'HashMap',
//    'Var':     'Var',
//    'Boolean': 'Boolean',
//    'String':  'String',
//    'Colour':  'String',
//    'Number':  'double'
//};
///**
// * Compute the Java declaration for an arbitrary type.
// * @param {string} type Blockly extended Type to make to a Java declaration.
// * @return {string} Java declaration best matching the type.
// */
//Blockly.Java.mapType = function(type) {
//    var mapType_ = function(typeMapping, typeArray) {
//        // If they gave us nothing or somehow called us in error then we want to
//        // pretend that the type is a Var
//        if (!typeArray || typeArray.length === 0) {
//            console.log('Empty type. Using Var');
//            typeArray = ['Var'];
//        }
//        var key = typeArray.shift();
//        var type = key;
//        if (typeMapping[type]) {
//            type = typeMapping[type];
//        } else if (Blockly.Blocks[type] && Blockly.Blocks[type].GBPClass ) {
//            type = Blockly.Blocks[type].GBPClass;
//        } else if (Blockly.VariableTypeEquivalence[type]) {
//            // We can use the type as is.
//        } else {
//            console.log('Unknown type for '+key+' using Var for '+type);
//            type = 'Var';
//        }
//
//        if (type === 'Var') {
//            Blockly.Java.provideVarClass();
//        }
//
//        // See if we have any sub elements
//        if (typeArray.length > 0) {
//            var subType = mapType_(Blockly.Java.subtypeMapping, typeArray);
//            type += '<'+subType+">";
//        }
//        return type;
//    }
//
//    var typeArray = null;
//    if (type) {
//        typeArray = type.split(':');
//    }
//
//    return mapType_(this.typeMapping, typeArray);
//
//};
//
///**
// * Get the Java type of a variable by name
// * @param {string} variable Name of the variable to get the type for
// * @return {string} type Java type for the variable
// */
//Blockly.Java.GetVariableType = function(name) {
//    var type = this.variableTypes_[name];
//    if (!type) {
////    type = 'String';
//        type = 'Var';
//        Blockly.Java.provideVarClass();
//    }
//    return type;
//};

/**
 * Prepend the generated code with the variable definitions.
 * @param {string} code Generated code.
 * @return {string} Completed code.
 */
Blockly.Java.finish = function (code) {
    // Convert the definitions dictionary into a list.
    var definitions = {};
    var funcs = [[], []];
    for (var name in this.definitions_) {
        if (name === 'variables') {
            continue;
        }
        var def = this.definitions_[name];
        var slot = 1;
        // If the call back for the definition is a function we will asssume that
        // it is not static
        if (typeof def !== "function") {
            // Since we have the text for the function, let's figure out if it is
            // static and sort it first.  Just look at the first two words of the
            // function and if it has 'static' we are good
            var head = def.split(" ", 3);
            if (goog.array.contains(head, 'static')) {
                slot = 0;
            }
        }
        funcs[slot].push(name);
    }

    // We have all the functions broken into two slots.  So go through in order
    // and get the statics and then the non-statics to output.
    var allDefs = '';

    for (var def in this.globals_) {
        var initializer = '';
        var type = this.GetVariableType(def);
        if (this.globals_[def] != null && this.globals_[def] !== '') {
            initializer = ' = ' + this.globals_[def];
        } else if (type === 'Var') {
            initializer = ' = new Var(0)';
        } else if (type === 'Boolean') {
            initializer = ' = false';
        } else if (type === 'String') {
            initializer = ' = ""';
        }
        var varname = Blockly.Java.variableDB_.getName(def,
            Blockly.Variables.NAME_TYPE);
        allDefs += 'protected ' + type + ' ' + varname + initializer + ';\n';
    }

    for (var slot = 0; slot < 2; slot++) {
        var names = funcs[slot].sort();
        for (var pos = 0; pos < names.length; pos++) {
            var def = this.definitions_[names[pos]];
            if (typeof def === "function") {
                def = def.call(this);
            }

            // Figure out the header to put on the function
            var header = '';
            var res1 = def.split("(", 2);
            if ((res1.length >= 2) && (res1[0].indexOf(";") === -1)) {
                // Figure out the header to put on the function
                var header = '';
                var extra = '\n';
                var res = res1[0];  // Get everything before the (
                var res2 = res.split(" ");
                var rettype = res2[res2.length - 2]; // The next to the last word
                res = res1[1];  // Take the parameters after the (
                res2 = res.split(")", 1);
                res = res2[0].trim();
                if (res !== '') {
                    var args = res.split(",");
                    for (var arg = 0; arg < args.length; arg++) {
                        var argline = args[arg].split(" ");
                        extra = '';
                    }
                }
                if (rettype !== 'void' && rettype !== 'public') {
                    extra = '';
                }

            }

            allDefs += header + def + '\n\n';
        }
    }

    //clean variable list, and add to code
    var variables = this.Variables;
    var blocklyDefined = Blockly.workspace_.getAllVariables();
    var variableCode = "";

    for(var i = 0; i < variables.length; i++){
        var found = false;
        blocklyDefined.forEach(function(variable){
            if(variable.name == variables[i].name){
                variableCode += variables[i].type + " " + variables[i].name + ";\n";
                found = true;
            }
        });
        if(!found){
            console.log("Removing variable: " + variables[i].name);
            this.removeVariable(variables[i].name);
        }
    }

    // Clean up temporary data.
    delete Blockly.Java.definitions_;
    delete Blockly.Java.functionNames_;
    //Blockly.Java.variableDB_.reset();
    return allDefs.replace(/\n\n+/g, '\n\n').replace(/\n*$/, '\n\n\n') + variableCode + code;
    //return code;
};

/**
 * Encode a string as a properly escaped Java string, complete with quotes.
 * @param {string} string Text to encode.
 * @return {string} Java string.
 * @private
 */
Blockly.Java.quote_ = function(string) {
    return goog.string.quote(string);
};

/**
 * Common tasks for generating Java from blocks.
 * Handles comments for the specified block and any connected value blocks.
 * Calls any statements following this block.
 * @param {!Blockly.Block} block The current block.
 * @param {string} code The Java code created for this block.
 * @return {string} Java code with comments and subsequent blocks added.
 * @private
 */
Blockly.Java.scrub_ = function (block, code, parms) {
    var nextBlock = block.nextConnection && block.nextConnection.targetBlock();
    var nextCode = this.blockToCode(nextBlock, parms);

    return code + nextCode;
};

Blockly.Java.setShipName = function setShipName(name) {
    if (!name || name === '') {
        name = 'MyShip';
    }
    this.ShipName = name;
};
Blockly.Java.getShipName = function getShipName() {
    return this.ShipName;
};

Blockly.Java.setAPILevel = function setAPILevel(API){
    if (!API || API === '') {
        API = 'Beginner';
    }
    this.API = API;
};
Blockly.Java.getAPILevel = function getAPILevel(){
    return this.API;
};

Blockly.Java.setBaseClass = function setBaseClass(baseClass) {
    if (!baseClass || baseClass === '') {
        baseClass = 'CorvetteShip';
    }
    this.addImport('robocode.' + baseClass);
    this.BaseClass = baseClass;
};
Blockly.Java.getBaseClass = function getBaseClass() {
    return this.BaseClass;
};

Blockly.Java.getPackage = function getPackage() {
    return this.Package;
};
Blockly.Java.setPackage = function setPackage(pkg){
    if (!pkg || pkg === '') {
        pkg = 'BlocklyShips';
    }
    this.Package = pkg;
}

Blockly.Java.getSlots = function getSlots() {
    return this.Slots_;
};
Blockly.Java.addSlot = function setSlot(component) {
    this.Slots_.push(component);
    var importString = 'robocode.naval.Components.';
    var API = Blockly.Java.getAPILevel();
    switch (component) {
        case 'DoubleBarrelCannon':
            importString += 'CannonComponents.DoubleBarrelCannon';
            (API == "Beginner")?this.addSlotMethods(this.Slots_.length, Blockly.Constants.values.BEGINNER_CANNON_METHODS) : this.addSlotMethods(this.Slots_.length, Blockly.Constants.values.INTERMEDIATE_CANNON_METHODS) ;
            break;
        case 'SingleBarrelCannon':
            importString += 'CannonComponents.SingleBarrelCannon';
            (API == "Beginner")?this.addSlotMethods(this.Slots_.length, Blockly.Constants.values.BEGINNER_CANNON_METHODS) : this.addSlotMethods(this.Slots_.length, Blockly.Constants.values.INTERMEDIATE_CANNON_METHODS) ;
            break;
        case 'LongRangeRadar':
            importString += 'RadarComponents.LongRangeRadar';
            (API == "Beginner")?this.addSlotMethods(this.Slots_.length, Blockly.Constants.values.BEGINNER_RADAR_METHODS) : this.addSlotMethods(this.Slots_.length, Blockly.Constants.values.INTERMEDIATE_RADAR_METHODS);
            break;
        case 'ShortRangeRadar':
            importString += 'RadarComponents.ShortRangeRadar';
            (API == "Beginner")?this.addSlotMethods(this.Slots_.length, Blockly.Constants.values.BEGINNER_RADAR_METHODS) : this.addSlotMethods(this.Slots_.length, Blockly.Constants.values.INTERMEDIATE_RADAR_METHODS);
            break;
        case 'MineComponent':
            importString += 'MineComponent';
            (API == "Beginner")?this.addSlotMethods(this.Slots_.length, Blockly.Constants.values.BEGINNER_MINE_METHODS) : this.addSlotMethods(this.Slots_.length, Blockly.Constants.values.INTERMEDIATE_MINE_METHODS);
            break;
        case 'MissileComponent':
            importString += 'MissileComponent';
            (API == "Beginner")?this.addSlotMethods(this.Slots_.length, Blockly.Constants.values.BEGINNER_MISSILE_METHODS): this.addSlotMethods(this.Slots_.length, Blockly.Constants.values.INTERMEDIATE_MISSILE_METHODS);
            break;
    }
    this.addImport(importString);
};

Blockly.Java.getImports = function () {
    if (this.Imports.length === 0) {
        return null;
    }
    return this.Imports;
};
Blockly.Java.addImport = function (i) {
    if (!goog.array.contains(this.Imports, i)) {
        this.Imports.push(i);
    }
};

Blockly.Java.addVariable = function(variable, type){
    if(!goog.array.contains(this.Variables, variable)){
        var v = {};
        v.name = variable;
        v.type = type;
        this.Variables.push(v);
    }
};
Blockly.Java.removeVariable = function(variable){
    if(goog.array.contains(this.Variables, variable)){
        goog.array.remove(this.Variables, variable);
    }
};
Blockly.Java.setVariableType = function(name, type){
    var variables = this.Variables;
    for(var i = 0; i < variables.length; i++){
        if(variables[i].name == name){
            variables[i].type = type;
        }
    }
};
Blockly.Java.getVariable = function getVariable(name){
    var variables = this.Variables;
    for(var i = 0; i < variables.length; i++){
        if(variables[i].name == name){
            return variables[i];
        }
    }
    return null;
};

Blockly.Java.addSlotMethods = function (slotIndex, methods) {
    console.log(methods);
    switch (slotIndex) {
        case 1:
            this.slot1Methods = methods;
            break;
        case 2:
            this.slot2Methods = methods;
            break;
        case 3:
            this.slot3Methods = methods;
            break;
        case 4:
            this.slot4Methods = methods;
            break;
        default:
            alert("INVALID SLOT INDEX: " + slotIndex);
            break;
    }
};
Blockly.Java.getSlotMethods = function (slotIndex) {
    switch (slotIndex) {
        case 1:
            return this.slot1Methods;
        case 2:
            return this.slot2Methods;
        case 3:
            return this.slot3Methods;
        case 4:
            return this.slot4Methods;
        default:
            alert("INVALID SLOT INDEX: " + slotIndex);
            break;
    }
};

Blockly.Java.getErrorMessages = function(block){
    var curData = block.data;
    var JSONData = JSON.parse(curData);
    if(!JSONData){
        JSONData = {};
    }
    //console.log(JSONData);
    if(!JSONData.error){
        JSONData.error = [];
    }

    //alert(JSON.stringify(JSONData));
}

